% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/partials.R
\name{partial}
\alias{partial}
\title{Better, nicer, friendlier partial dependence plots}
\usage{
partial(
  model,
  x.vars = NULL,
  equal = TRUE,
  smooth = 1,
  ci = TRUE,
  ciwidth = 0.95,
  trace = TRUE,
  transform = TRUE,
  panels = FALSE
)
}
\arguments{
\item{model}{A dbarts model object}

\item{x.vars}{A list of the variables for which you want to run the partials. Defaults to doing all of them.}

\item{equal}{Spacing x levels equally instead of using quantiles, which is how dbarts does this normally (the distribution of points reflects the distribution of samples in the data - this makes weird patterns that don't look very smooth)}

\item{smooth}{A multiplier for how much smoother you want the sampling of the levels to be. High values, like 10 or over, are obviously much slower and don't add much.}

\item{ci}{Plot a given \% credible interval with a blue bar. Defaults to 95\% and controlled by ciwidth}

\item{ciwidth}{Specify the width of the plotted credible issue}

\item{trace}{Traceplots for each individual draw from the posterior}

\item{transform}{This converts from the logit output of dbarts:::predict to actual 0 to 1 probabilities. I wouldn't turn this off unless you're really interested in a deep dive on the model.}

\item{panels}{For multiple variables, use this to create a multipanel figure.}
}
\value{
Returns a ggplot object or cowplot object.
}
\description{
Partial dependence plots show the response curves of an individual variable in the sum-of-trees models. The main line is the average of partial dependence plots for each posterior draw of sum-of-trees models; each of those curves is generated by evaluating the BART model prediction at each specified x value for *each other combination of other x values in the data*. This is obviously computationally very expensive, and gets slower to run depending on: how much smooth you add, how many variables you ask for, and more posterior draws (ndpost; defaults to 1000) in the bart() function.
}
\examples{
f <- function(x) { return(0.5 * x[,1] + 2 * x[,2] * x[,3]) - 5*x[,4] }
sigma <- 0.2
n <- 100
x <- matrix(2 * runif(n * 3) -1, ncol = 3)
x <- data.frame(x)
x[,4] <- rbinom(100, 1, 0.3)
colnames(x) <- c('rob', 'hugh', 'ed', 'phil')
Ey <- f(x)
y  <- rnorm(n, Ey, sigma)
df <- data.frame(y, x)
set.seed(99)

bartFit <- bart(y ~ rob + hugh + ed + phil, df,
               keepevery = 10, ntree = 100, keeptrees = TRUE)

partial(bartFit, x.vars='hugh', trace=TRUE, ci=TRUE)
partial(bartFit, x.vars='hugh', equal=TRUE, trace=TRUE, ci=TRUE)
partial(bartFit, x.vars='hugh', equal=TRUE, smooth=10, trace=TRUE, ci=TRUE)

partial(bartFit, x.vars='rob', equal=TRUE, smooth=10, trace=FALSE, ci=TRUE)
partial(bartFit, x.vars='ed', equal=TRUE, smooth=10, trace=TRUE, ci=FALSE)
partial(bartFit, equal=TRUE, smooth=10, trace=FALSE, ci=TRUE, panels=TRUE)

}
