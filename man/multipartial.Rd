% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multipartial.R
\name{multipartial}
\alias{multipartial}
\title{Multispecies partial plots (in development)}
\usage{
multipartial(
  modl,
  spnames,
  x.vars = NULL,
  smooth = 7,
  trace = TRUE,
  transform = TRUE,
  panels = FALSE
)
}
\arguments{
\item{x.vars}{A list of the variables for which you want to run the partials. Defaults to doing all of them.}

\item{smooth}{A multiplier for how much smoother you want the sampling of the levels to be. High values, like 10 or over, are obviously much slower and don't add much.}

\item{trace}{Traceplots for each individual draw from the posterior}

\item{transform}{This converts from the logit output of dbarts:::predict to actual 0 to 1 probabilities. I wouldn't turn this off unless you're really interested in a deep dive on the model.}

\item{panels}{For multiple variables, use this to create a multipanel figure.}

\item{model}{A dbarts model object}
}
\value{
Returns a ggplot object or cowplot object.
}
\description{
Partial dependence plots show the response curves of an individual variable in the sum-of-trees models. The main line is the average of partial dependence plots for each posterior draw of sum-of-trees models; each of those curves is generated by evaluating the BART model prediction at each specified x value for *each other combination of other x values in the data*. This is obviously computationally very expensive, and gets slower to run depending on: how much smooth you add, how many variables you ask for, and more posterior draws (ndpost; defaults to 1000) in the bart() function.

This is a somewhat altered and simplified version of partial() that allows you to combine different species' responses to the same variables on the same axes. Run the models separately, then use this function to combine them.
}
\examples{
f <- function(x) { return(0.5 * x[,1] + 3 * x[,2] * x[,3]) - 5*x[,4] }
g <- function(x) { return(0.6 * (x[,1]-0.3) + 1 * x[,2] * x[,3]) - 5*x[,4] }
sigma <- 0.2
n <- 100
x <- matrix(2 * runif(n * 3) -1, ncol = 3)
x <- data.frame(x)
x[,4] <- rbinom(100, 1, 0.3)
colnames(x) <- c('rob', 'hugh', 'ed', 'phil')
Ey <- f(x)
y  <- rnorm(n, Ey, sigma)
Ez <- g(x)
z  <- rnorm(n, Ez, sigma)
df <- data.frame(z, y, x)
set.seed(99)

bartFit1 <- bart(y ~ rob + hugh + ed + phil, df,
                 keepevery = 10, ntree = 100, keeptrees = TRUE)

bartFit2 <- bart(z ~ rob + hugh + ed + phil, df,
                 keepevery = 10, ntree = 100, keeptrees = TRUE)

model.list <- list(bartFit1, bartFit2)

multipartial(modl = model.list, spnames = c('Y','Z'), 
             x.vars = c('rob','hugh'),
             smooth = 7, trace = TRUE, panels = TRUE)
             
}
